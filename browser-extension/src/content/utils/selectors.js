/**
 * Utilitarios para geracao e busca de seletores
 * Optimized for modern web apps with data-testid, aria-label, etc.
 */

export { findLabelForField, findField, findFieldByLabel } from './selectors/field-finder.js';
export { findElementByText, getClickableElements } from './selectors/text-finder.js';

/**
 * Check if an ID looks auto-generated (random hash, UUID-like, etc.)
 */
function isAutoGeneratedId(id) {
  if (!id) return true;

  // Common patterns for auto-generated IDs
  const autoGenPatterns = [
    /^[a-f0-9]{8,}$/i,           // Hex hashes
    /^[a-z0-9]{20,}$/i,          // Long random strings
    /^:r[0-9a-z]+:$/i,           // React IDs like :r0:
    /^ember\d+$/i,               // Ember IDs
    /^ng-[a-z]+-\d+$/i,          // Angular IDs
    /^[a-z]+-[a-f0-9-]{36}$/i,   // UUID-based
    /^\d+$/,                     // Pure numeric
    /^ext-\d+$/i,                // ExtJS IDs
    /^gwt-uid-\d+$/i,            // GWT IDs
    /^yui_\d+/i,                 // YUI IDs
    /^_[a-z0-9]{8,}$/i,          // Underscore + hash
  ];

  return autoGenPatterns.some(pattern => pattern.test(id));
}

/**
 * Get test ID attribute (supports common conventions)
 */
function getTestId(element) {
  return element.getAttribute('data-testid') ||
         element.getAttribute('data-test-id') ||
         element.getAttribute('data-cy') ||
         element.getAttribute('data-test') ||
         element.getAttribute('data-qa');
}

/**
 * Gera um seletor CSS para um elemento
 * Priority order:
 * 1. data-testid / data-test-id / data-cy (most stable for testing)
 * 2. aria-label (semantic and stable)
 * 3. id (if not auto-generated)
 * 4. name attribute
 * 5. role + accessible name
 * 6. Fallback to path-based selector
 */
export function generateSelector(element) {
  if (!element) return null;

  // 1. Test IDs (highest priority - explicitly set for testing)
  const testId = getTestId(element);
  if (testId) {
    // Use the specific attribute that was found
    if (element.getAttribute('data-testid')) return `[data-testid="${testId}"]`;
    if (element.getAttribute('data-test-id')) return `[data-test-id="${testId}"]`;
    if (element.getAttribute('data-cy')) return `[data-cy="${testId}"]`;
    if (element.getAttribute('data-test')) return `[data-test="${testId}"]`;
    if (element.getAttribute('data-qa')) return `[data-qa="${testId}"]`;
  }

  // 2. aria-label (semantic and typically stable)
  const ariaLabel = element.getAttribute('aria-label');
  if (ariaLabel && ariaLabel.length <= 50) {
    // Escape quotes in the value
    const escaped = ariaLabel.replace(/"/g, '\\"');
    return `[aria-label="${escaped}"]`;
  }

  // 3. ID (only if not auto-generated)
  if (element.id && !isAutoGeneratedId(element.id)) {
    return `#${element.id}`;
  }

  // 4. name attribute (common for form elements)
  if (element.name) {
    return `[name="${element.name}"]`;
  }

  // 5. Role + accessible name combination
  const role = element.getAttribute('role');
  const accessibleName = ariaLabel || element.title ||
                        (element.tagName === 'INPUT' ? element.placeholder : null);
  if (role && accessibleName && accessibleName.length <= 30) {
    const escaped = accessibleName.replace(/"/g, '\\"');
    return `[role="${role}"][aria-label="${escaped}"]`;
  }

  // 6. title attribute (often used as tooltip/label)
  if (element.title && element.title.length <= 50) {
    const escaped = element.title.replace(/"/g, '\\"');
    return `[title="${escaped}"]`;
  }

  // 7. Fallback to path-based selector
  return generatePathSelector(element);
}

/**
 * Generate a path-based CSS selector (fallback method)
 */
export function generatePathSelector(element) {
  const path = [];
  let current = element;

  while (current && current !== document.body) {
    let selector = current.tagName.toLowerCase();

    // Add classes for specificity (exclude dynamic/state classes)
    if (current.className && typeof current.className === 'string') {
      const classes = current.className.trim().split(/\s+/)
        .filter(c => c &&
                !c.includes(':') &&
                !c.startsWith('is-') &&
                !c.startsWith('has-') &&
                !c.includes('active') &&
                !c.includes('hover') &&
                !c.includes('focus') &&
                !c.includes('selected') &&
                c.length < 30);
      if (classes.length > 0) {
        selector += '.' + classes.slice(0, 2).join('.');
      }
    }

    // Add nth-of-type if there are siblings
    const siblings = current.parentElement?.querySelectorAll(`:scope > ${current.tagName.toLowerCase()}`);
    if (siblings && siblings.length > 1) {
      const index = [...siblings].indexOf(current) + 1;
      selector += `:nth-of-type(${index})`;
    }

    path.unshift(selector);
    current = current.parentElement;

    // Limit path depth
    if (path.length > 4) break;
  }

  return path.join(' > ');
}

/**
 * Gera seletores alternativos para um elemento (ordered by stability)
 */
export function generateAlternativeSelectors(element) {
  const selectors = [];
  const seen = new Set();

  const addSelector = (sel) => {
    if (sel && !seen.has(sel)) {
      seen.add(sel);
      selectors.push(sel);
    }
  };

  // 1. Test IDs (most stable)
  const testId = getTestId(element);
  if (testId) {
    if (element.getAttribute('data-testid')) addSelector(`[data-testid="${testId}"]`);
    if (element.getAttribute('data-test-id')) addSelector(`[data-test-id="${testId}"]`);
    if (element.getAttribute('data-cy')) addSelector(`[data-cy="${testId}"]`);
    if (element.getAttribute('data-test')) addSelector(`[data-test="${testId}"]`);
    if (element.getAttribute('data-qa')) addSelector(`[data-qa="${testId}"]`);
  }

  // 2. aria-label
  if (element.getAttribute('aria-label')) {
    const escaped = element.getAttribute('aria-label').replace(/"/g, '\\"');
    addSelector(`[aria-label="${escaped}"]`);
  }

  // 3. ID (if not auto-generated)
  if (element.id && !isAutoGeneratedId(element.id)) {
    addSelector(`#${element.id}`);
  }

  // 4. name attribute
  if (element.name) {
    addSelector(`[name="${element.name}"]`);
  }

  // 5. role + name
  const role = element.getAttribute('role');
  if (role) {
    const name = element.getAttribute('aria-label') || element.title;
    if (name) {
      const escaped = name.replace(/"/g, '\\"');
      addSelector(`[role="${role}"][aria-label="${escaped}"]`);
    }
  }

  // 6. title
  if (element.title) {
    const escaped = element.title.replace(/"/g, '\\"');
    addSelector(`[title="${escaped}"]`);
  }

  // 7. Fallback path selector
  addSelector(generatePathSelector(element));

  return selectors;
}
