/**
 * Utilitários para geração e busca de seletores
 * Optimized for modern web apps with data-testid, aria-label, etc.
 */

import { isVisible, getElementDepth, getDirectTextContent, findClickableParent } from './dom.js';

/**
 * Check if an ID looks auto-generated (random hash, UUID-like, etc.)
 */
function isAutoGeneratedId(id) {
  if (!id) return true;

  // Common patterns for auto-generated IDs
  const autoGenPatterns = [
    /^[a-f0-9]{8,}$/i,           // Hex hashes
    /^[a-z0-9]{20,}$/i,          // Long random strings
    /^:r[0-9a-z]+:$/i,           // React IDs like :r0:
    /^ember\d+$/i,               // Ember IDs
    /^ng-[a-z]+-\d+$/i,          // Angular IDs
    /^[a-z]+-[a-f0-9-]{36}$/i,   // UUID-based
    /^\d+$/,                     // Pure numeric
    /^ext-\d+$/i,                // ExtJS IDs
    /^gwt-uid-\d+$/i,            // GWT IDs
    /^yui_\d+/i,                 // YUI IDs
    /^_[a-z0-9]{8,}$/i,          // Underscore + hash
  ];

  return autoGenPatterns.some(pattern => pattern.test(id));
}

/**
 * Get test ID attribute (supports common conventions)
 */
function getTestId(element) {
  return element.getAttribute('data-testid') ||
         element.getAttribute('data-test-id') ||
         element.getAttribute('data-cy') ||
         element.getAttribute('data-test') ||
         element.getAttribute('data-qa');
}

/**
 * Gera um seletor CSS para um elemento
 * Priority order:
 * 1. data-testid / data-test-id / data-cy (most stable for testing)
 * 2. aria-label (semantic and stable)
 * 3. id (if not auto-generated)
 * 4. name attribute
 * 5. role + accessible name
 * 6. Fallback to path-based selector
 */
export function generateSelector(element) {
  if (!element) return null;

  // 1. Test IDs (highest priority - explicitly set for testing)
  const testId = getTestId(element);
  if (testId) {
    // Use the specific attribute that was found
    if (element.getAttribute('data-testid')) return `[data-testid="${testId}"]`;
    if (element.getAttribute('data-test-id')) return `[data-test-id="${testId}"]`;
    if (element.getAttribute('data-cy')) return `[data-cy="${testId}"]`;
    if (element.getAttribute('data-test')) return `[data-test="${testId}"]`;
    if (element.getAttribute('data-qa')) return `[data-qa="${testId}"]`;
  }

  // 2. aria-label (semantic and typically stable)
  const ariaLabel = element.getAttribute('aria-label');
  if (ariaLabel && ariaLabel.length <= 50) {
    // Escape quotes in the value
    const escaped = ariaLabel.replace(/"/g, '\\"');
    return `[aria-label="${escaped}"]`;
  }

  // 3. ID (only if not auto-generated)
  if (element.id && !isAutoGeneratedId(element.id)) {
    return `#${element.id}`;
  }

  // 4. name attribute (common for form elements)
  if (element.name) {
    return `[name="${element.name}"]`;
  }

  // 5. Role + accessible name combination
  const role = element.getAttribute('role');
  const accessibleName = ariaLabel || element.title ||
                        (element.tagName === 'INPUT' ? element.placeholder : null);
  if (role && accessibleName && accessibleName.length <= 30) {
    const escaped = accessibleName.replace(/"/g, '\\"');
    return `[role="${role}"][aria-label="${escaped}"]`;
  }

  // 6. title attribute (often used as tooltip/label)
  if (element.title && element.title.length <= 50) {
    const escaped = element.title.replace(/"/g, '\\"');
    return `[title="${escaped}"]`;
  }

  // 7. Fallback to path-based selector
  return generatePathSelector(element);
}

/**
 * Generate a path-based CSS selector (fallback method)
 */
function generatePathSelector(element) {
  const path = [];
  let current = element;

  while (current && current !== document.body) {
    let selector = current.tagName.toLowerCase();

    // Add classes for specificity (exclude dynamic/state classes)
    if (current.className && typeof current.className === 'string') {
      const classes = current.className.trim().split(/\s+/)
        .filter(c => c &&
                !c.includes(':') &&
                !c.startsWith('is-') &&
                !c.startsWith('has-') &&
                !c.includes('active') &&
                !c.includes('hover') &&
                !c.includes('focus') &&
                !c.includes('selected') &&
                c.length < 30);
      if (classes.length > 0) {
        selector += '.' + classes.slice(0, 2).join('.');
      }
    }

    // Add nth-of-type if there are siblings
    const siblings = current.parentElement?.querySelectorAll(`:scope > ${current.tagName.toLowerCase()}`);
    if (siblings && siblings.length > 1) {
      const index = [...siblings].indexOf(current) + 1;
      selector += `:nth-of-type(${index})`;
    }

    path.unshift(selector);
    current = current.parentElement;

    // Limit path depth
    if (path.length > 4) break;
  }

  return path.join(' > ');
}

/**
 * Gera seletores alternativos para um elemento (ordered by stability)
 */
export function generateAlternativeSelectors(element) {
  const selectors = [];
  const seen = new Set();

  const addSelector = (sel) => {
    if (sel && !seen.has(sel)) {
      seen.add(sel);
      selectors.push(sel);
    }
  };

  // 1. Test IDs (most stable)
  const testId = getTestId(element);
  if (testId) {
    if (element.getAttribute('data-testid')) addSelector(`[data-testid="${testId}"]`);
    if (element.getAttribute('data-test-id')) addSelector(`[data-test-id="${testId}"]`);
    if (element.getAttribute('data-cy')) addSelector(`[data-cy="${testId}"]`);
    if (element.getAttribute('data-test')) addSelector(`[data-test="${testId}"]`);
    if (element.getAttribute('data-qa')) addSelector(`[data-qa="${testId}"]`);
  }

  // 2. aria-label
  if (element.getAttribute('aria-label')) {
    const escaped = element.getAttribute('aria-label').replace(/"/g, '\\"');
    addSelector(`[aria-label="${escaped}"]`);
  }

  // 3. ID (if not auto-generated)
  if (element.id && !isAutoGeneratedId(element.id)) {
    addSelector(`#${element.id}`);
  }

  // 4. name attribute
  if (element.name) {
    addSelector(`[name="${element.name}"]`);
  }

  // 5. role + name
  const role = element.getAttribute('role');
  if (role) {
    const name = element.getAttribute('aria-label') || element.title;
    if (name) {
      const escaped = name.replace(/"/g, '\\"');
      addSelector(`[role="${role}"][aria-label="${escaped}"]`);
    }
  }

  // 6. title
  if (element.title) {
    const escaped = element.title.replace(/"/g, '\\"');
    addSelector(`[title="${escaped}"]`);
  }

  // 7. Fallback path selector
  addSelector(generatePathSelector(element));

  return selectors;
}

/**
 * Encontra label associada a um campo
 */
export function findLabelForField(field) {
  if (field.id) {
    const label = document.querySelector(`label[for="${field.id}"]`);
    if (label) return label.textContent?.trim();
  }

  const parent = field.closest('label');
  if (parent) {
    return parent.textContent?.replace(field.value || '', '').trim();
  }

  if (field.getAttribute('aria-label')) {
    return field.getAttribute('aria-label');
  }

  if (field.placeholder) {
    return field.placeholder;
  }

  return field.name || field.id || null;
}

/**
 * Encontra um campo por seletor ou label
 */
export function findField(selector, label) {
  if (selector) {
    const field = document.querySelector(selector);
    if (field) return field;
  }

  if (label) {
    return findFieldByLabel(label);
  }

  return null;
}

/**
 * Encontra campo por label
 */
export function findFieldByLabel(label) {
  const labelLower = label.toLowerCase();

  const labels = [...document.querySelectorAll('label')];
  for (const labelEl of labels) {
    if (labelEl.textContent?.toLowerCase().includes(labelLower)) {
      if (labelEl.htmlFor) {
        const field = document.getElementById(labelEl.htmlFor);
        if (field) return field;
      }

      const field = labelEl.querySelector('input, select, textarea');
      if (field) return field;
    }
  }

  const byPlaceholder = document.querySelector(
    `input[placeholder*="${label}" i], textarea[placeholder*="${label}" i]`
  );
  if (byPlaceholder) return byPlaceholder;

  const byAria = document.querySelector(`[aria-label*="${label}" i]`);
  if (byAria) return byAria;

  const normalizedLabel = label.toLowerCase().replace(/\s+/g, '');
  const inputs = document.querySelectorAll('input, select, textarea');
  for (const input of inputs) {
    const name = (input.name || '').toLowerCase().replace(/[_-]/g, '');
    if (name.includes(normalizedLabel)) return input;
  }

  return null;
}

/**
 * Encontra elemento por texto
 */
export function findElementByText(text) {
  const textLower = text.toLowerCase().trim();

  // 1. Primeiro tenta botões e inputs (alta prioridade)
  const buttons = document.querySelectorAll('button, input[type="submit"], input[type="button"], [role="button"]');
  for (const btn of buttons) {
    const btnText = (btn.textContent || btn.value || '').toLowerCase().trim();
    if (btnText.includes(textLower) && isVisible(btn)) return btn;
  }

  // 2. Tenta links
  const links = document.querySelectorAll('a');
  for (const link of links) {
    if (link.textContent?.toLowerCase().trim().includes(textLower) && isVisible(link)) return link;
  }

  // 3. Tenta elementos com onclick ou role
  const clickables = document.querySelectorAll('[onclick], [role="button"], [role="link"], [role="menuitem"], [role="option"], [role="listitem"]');
  for (const el of clickables) {
    if (el.textContent?.toLowerCase().trim().includes(textLower) && isVisible(el)) return el;
  }

  // 4. Tenta elementos com data-testid ou aria-label
  const dataElements = document.querySelectorAll('[data-testid], [aria-label]');
  for (const el of dataElements) {
    const ariaLabel = el.getAttribute('aria-label')?.toLowerCase() || '';
    const testId = el.getAttribute('data-testid')?.toLowerCase() || '';
    if ((ariaLabel.includes(textLower) || testId.includes(textLower)) && isVisible(el)) return el;
  }

  // 5. Busca em spans e divs com título
  const titledElements = document.querySelectorAll('[title]');
  for (const el of titledElements) {
    if (el.getAttribute('title')?.toLowerCase().includes(textLower) && isVisible(el)) {
      return findClickableParent(el) || el;
    }
  }

  // 6. Último recurso: busca em qualquer elemento visível
  const allElements = [...document.querySelectorAll('div, span, li, td, p, label')];

  allElements.sort((a, b) => {
    const depthA = getElementDepth(a);
    const depthB = getElementDepth(b);
    return depthB - depthA;
  });

  for (const el of allElements) {
    if (!isVisible(el)) continue;

    const directText = getDirectTextContent(el).toLowerCase().trim();
    if (directText.includes(textLower)) {
      return findClickableParent(el) || el;
    }
  }

  return null;
}

/**
 * Retorna lista de elementos clicáveis na página
 */
export function getClickableElements() {
  const clickables = [];
  const seen = new Set();

  const selectors = [
    'button', 'a[href]', 'input[type="submit"]', 'input[type="button"]',
    '[role="button"]', '[role="link"]', '[role="menuitem"]', '[role="option"]',
    '[role="listitem"]', '[onclick]', '[tabindex="0"]', '[data-testid]'
  ];

  document.querySelectorAll(selectors.join(', ')).forEach(el => {
    if (!isVisible(el)) return;

    const text = (el.textContent || el.value || el.getAttribute('aria-label') || '').trim();
    const key = `${text}-${el.tagName}-${el.className}`;

    if (seen.has(key) || !text) return;
    seen.add(key);

    clickables.push({
      text: text.substring(0, 100),
      tagName: el.tagName.toLowerCase(),
      type: el.type || el.getAttribute('role') || 'element',
      selector: generateSelector(el),
      id: el.id || null,
      testId: el.getAttribute('data-testid') || null,
      ariaLabel: el.getAttribute('aria-label') || null
    });
  });

  return clickables.slice(0, 100);
}
